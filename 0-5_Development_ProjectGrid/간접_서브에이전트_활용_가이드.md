# 간접 서브 에이전트 활용 완벽 가이드

**작성일**: 2025-10-31
**목적**: Custom Agent를 Built-in Agent를 통해 간접 소환하는 방법

---

## 📚 목차

1. [배경: 왜 간접 소환인가?](#배경-왜-간접-소환인가)
2. [2단계 매핑 구조](#2단계-매핑-구조)
3. [간접 소환 원리](#간접-소환-원리)
4. [실제 구현 방법](#실제-구현-방법)
5. [통합 실행기](#통합-실행기)
6. [FAQ](#faq)

---

## 배경: 왜 간접 소환인가?

### 직접 소환이 안 되는 이유

#### 1. 보안 문제
```
만약 직접 소환이 가능하다면:
- 악의적인 .md 파일로 시스템 파괴 가능
- 검증되지 않은 코드 실행 위험
```

#### 2. 품질 관리
```
Built-in Agent (4개):
- Anthropic이 직접 개발 및 테스트
- 안정성 보장

Custom Agent (14개):
- 사용자 작성
- 테스트 필요
```

#### 3. 기술 구조
```python
# Task tool의 subagent_type은 Enum으로 하드코딩
subagent_type: "general-purpose" | "Explore" | "statusline-setup" | "output-style-setup"

# 동적 추가 불가능
```

#### 4. 책임 범위
```
Built-in 사용 문제 → Anthropic 책임
Custom 직접 실행 문제 → 책임 소재 불명확
```

### 간접 소환의 장점

✅ **안전성**: Built-in Agent가 필터링
✅ **유연성**: .md 파일만 수정하면 즉시 반영
✅ **조합 가능**: 여러 Agent 역할 동시 부여
✅ **버전 관리**: Git으로 이력 관리 가능

---

## 2단계 매핑 구조

### 전체 흐름

```
[144개 Task]
    ↓
[1단계 매핑: Task → Custom Agent]
    ↓
[14개 Custom Agent]
    ↓
[2단계 매핑: Custom Agent → Built-in Agent]
    ↓
[4개 Built-in Agent]
    ↓
[실행]
```

### 1단계 매핑: Task → Custom Agent

| Area | 설명 | Task 수 | Custom Agent |
|------|------|---------|--------------|
| O | DevOps | 9 | devops-troubleshooter |
| D | Database | 30 | database-developer |
| BI | Backend Infrastructure | 3 | backend-developer |
| BA | Backend APIs | 53 | api-designer |
| F | Frontend | 31 | frontend-developer, ui-designer |
| T | Test | 18 | test-engineer, code-reviewer |

**매핑 로직**:
```python
def get_custom_agent(task_id: str) -> str:
    """Task ID에서 Custom Agent 추출"""
    # P1BA1 → BA → api-designer
    area = extract_area_from_task_id(task_id)

    mapping = {
        'O': 'devops-troubleshooter',
        'D': 'database-developer',
        'BI': 'backend-developer',
        'BA': 'api-designer',
        'F': 'frontend-developer',
        'T': 'test-engineer'
    }

    return mapping[area]
```

### 2단계 매핑: Custom Agent → Built-in Agent

| Built-in Agent | 용도 | 매핑되는 Custom Agent |
|----------------|------|---------------------|
| general-purpose | 범용 개발 | 11개 (대부분) |
| Explore | 코드 탐색 | code-reviewer (필요 시) |
| statusline-setup | 상태바 설정 | 없음 |
| output-style-setup | 출력 스타일 | 없음 |

**대부분 general-purpose 사용**:
```python
def get_builtin_agent(custom_agent: str) -> str:
    """Custom Agent → Built-in Agent"""
    # 특수 케이스만 처리
    if custom_agent == 'code-reviewer':
        return 'Explore'  # 코드 탐색 필요 시

    # 기본값: general-purpose
    return 'general-purpose'
```

---

## 간접 소환 원리

### 핵심 개념

**직접 소환 (불가능)**:
```python
# ❌ 작동 안 함
Task(
    subagent_type="api-designer",  # Custom Agent 직접 호출
    prompt="API 만들어줘"
)
# Error: Agent type 'api-designer' not found
```

**간접 소환 (작동)**:
```python
# ✅ 작동함
# 1. Custom Agent 역할 정의 읽기
agent_role = Read("/c/Users/home/.claude/agents/api-designer.md")

# 2. Built-in Agent에 역할 부여
Task(
    subagent_type="general-purpose",  # Built-in Agent
    prompt=f"""
{agent_role}

---

위 역할로 다음 작업을 수행하세요:
API 만들어줘
"""
)
```

### 비유로 이해하기

**배우와 연기**:
```
직접 소환 (불가능):
"api-designer야, 무대에 나와!" ❌
→ api-designer는 실제 배우가 아님

간접 소환 (가능):
"general-purpose야, 무대에 나와!" ✅
"여기 api-designer 대본 있어, 이 역할로 연기해!"
→ general-purpose가 api-designer 역할 연기
```

---

## 실제 구현 방법

### 방법 1: 수동 간접 소환

**단계별 과정**:

```markdown
1. Custom Agent 파일 읽기
→ Read("/c/Users/home/.claude/agents/api-designer.md")

2. 작업 지시서 읽기
→ Read("./tasks/P1BA1.md")

3. Task tool로 간접 소환
→ Task(
    subagent_type="general-purpose",
    description="API 설계 작업",
    prompt=f"""
{agent_content}

---

작업 지시:
{task_instruction}
"""
)
```

### 방법 2: 자동화된 간접 소환 (통합 실행기)

**통합 실행기 코드**:

```python
#!/usr/bin/env python3
"""
PROJECT GRID 통합 실행기
144개 작업을 자동으로 순차 실행
"""

import json
from pathlib import Path

class ProjectGridExecutor:
    """PROJECT GRID 자동 실행 시스템"""

    def __init__(self):
        self.base_dir = Path(__file__).parent
        self.tasks_file = self.base_dir / "generated_grid_full_v4.json"
        self.agents_dir = Path("/c/Users/home/.claude/agents")

        # 매핑 테이블
        self.agent_mapping = {
            'O': 'devops-troubleshooter',
            'D': 'database-developer',
            'BI': 'backend-developer',
            'BA': 'api-designer',
            'F': 'frontend-developer',
            'T': 'test-engineer'
        }

        # 실행 로그
        self.execution_log = []

    def load_tasks(self):
        """144개 작업 로드"""
        with open(self.tasks_file, 'r', encoding='utf-8') as f:
            return json.load(f)

    def get_custom_agent(self, task_id: str) -> str:
        """Task ID → Custom Agent"""
        # P1BA1 → BA
        area_code = ''.join([c for c in task_id[2:] if c.isalpha()])
        return self.agent_mapping.get(area_code, 'fullstack-developer')

    def load_agent_prompt(self, agent_name: str) -> str:
        """Custom Agent .md 파일 읽기"""
        agent_file = self.agents_dir / f"{agent_name}.md"

        if not agent_file.exists():
            return f"# {agent_name}\n\n기본 개발자 역할"

        with open(agent_file, 'r', encoding='utf-8') as f:
            return f.read()

    def load_task_instruction(self, task_id: str) -> str:
        """작업 지시서 읽기"""
        instruction_file = self.base_dir / "tasks" / f"{task_id}.md"

        with open(instruction_file, 'r', encoding='utf-8') as f:
            return f.read()

    def check_dependency(self, task: dict, completed_tasks: set) -> bool:
        """의존성 체크"""
        deps = task.get('dependency_chain', '없음')

        if deps == '없음':
            return True

        # 의존 작업들이 모두 완료되었는지 확인
        dep_list = [d.strip() for d in deps.split(',')]
        return all(dep in completed_tasks for dep in dep_list)

    def generate_execution_prompt(self, task: dict, agent_prompt: str, task_instruction: str) -> str:
        """실행 프롬프트 생성"""
        return f"""
{agent_prompt}

---

## 작업 정보

- Task ID: {task['task_id']}
- Task Name: {task['task_name']}
- Area: {task['area']}
- Phase: {task['phase']}

---

## 작업 지시

{task_instruction}

---

위 역할로 작업을 수행하고, 완료 후 다음을 보고하세요:
1. 생성된 파일 목록
2. 주요 구현 내용
3. 테스트 결과
4. 다음 의존 작업에 영향
"""

    def execute_task(self, task: dict) -> dict:
        """단일 작업 실행"""
        task_id = task['task_id']

        print(f"\n{'='*80}")
        print(f"EXECUTING: {task_id} - {task['task_name']}")
        print(f"{'='*80}")

        # 1. Custom Agent 결정
        custom_agent = self.get_custom_agent(task_id)
        print(f"[1단계] {task_id} → {custom_agent}")

        # 2. Built-in Agent 결정
        builtin_agent = 'general-purpose'
        print(f"[2단계] {custom_agent} → {builtin_agent}")

        # 3. Agent 역할 로드
        agent_prompt = self.load_agent_prompt(custom_agent)
        print(f"[로드] Agent: {len(agent_prompt)} 문자")

        # 4. 작업 지시서 로드
        task_instruction = self.load_task_instruction(task_id)
        print(f"[로드] Instruction: {len(task_instruction)} 문자")

        # 5. 실행 프롬프트 생성
        execution_prompt = self.generate_execution_prompt(
            task, agent_prompt, task_instruction
        )

        # 6. 실행 명령 반환
        execution_command = {
            'task_id': task_id,
            'task_name': task['task_name'],
            'custom_agent': custom_agent,
            'builtin_agent': builtin_agent,
            'execution_prompt': execution_prompt,
            'prompt_length': len(execution_prompt)
        }

        self.execution_log.append({
            'task_id': task_id,
            'status': 'ready',
            'custom_agent': custom_agent
        })

        return execution_command

    def run_all(self):
        """144개 작업 전체 실행"""
        tasks = self.load_tasks()
        completed = set()

        print(f"\n{'='*80}")
        print(f"PROJECT GRID 통합 실행기")
        print(f"총 {len(tasks)}개 작업")
        print(f"{'='*80}")

        # Phase별로 정렬
        tasks_by_phase = {}
        for task in tasks:
            phase = task['phase']
            if phase not in tasks_by_phase:
                tasks_by_phase[phase] = []
            tasks_by_phase[phase].append(task)

        # Phase별 순차 실행
        for phase in sorted(tasks_by_phase.keys()):
            print(f"\n\n{'#'*80}")
            print(f"# Phase {phase}: {len(tasks_by_phase[phase])}개 작업")
            print(f"{'#'*80}")

            phase_tasks = tasks_by_phase[phase]

            # 의존성 순서로 실행
            while phase_tasks:
                executed_in_round = []

                for task in phase_tasks:
                    # 의존성 체크
                    if self.check_dependency(task, completed):
                        # 실행 가능
                        cmd = self.execute_task(task)

                        # 여기서 실제로 Task tool 호출
                        print(f"\n[실행] Task tool 호출 준비:")
                        print(f"  - subagent_type: {cmd['builtin_agent']}")
                        print(f"  - prompt 길이: {cmd['prompt_length']} 문자")

                        # 완료 처리
                        completed.add(task['task_id'])
                        executed_in_round.append(task)

                # 실행된 작업 제거
                for task in executed_in_round:
                    phase_tasks.remove(task)

                # 무한 루프 방지
                if not executed_in_round and phase_tasks:
                    print(f"\n[경고] 의존성 문제로 실행 불가: {[t['task_id'] for t in phase_tasks]}")
                    break

        # 실행 로그 저장
        log_file = self.base_dir / "execution_log.json"
        with open(log_file, 'w', encoding='utf-8') as f:
            json.dump(self.execution_log, f, ensure_ascii=False, indent=2)

        print(f"\n\n{'='*80}")
        print(f"실행 완료: {len(completed)}/{len(tasks)}개")
        print(f"로그 저장: {log_file}")
        print(f"{'='*80}")

# 실행
if __name__ == "__main__":
    executor = ProjectGridExecutor()
    executor.run_all()
```

---

## 통합 실행기

### 특징

✅ **완전 자동**: 144개 작업 순차 실행
✅ **의존성 관리**: dependency_chain 자동 체크
✅ **Phase 순서**: Phase 1 → 2 → ... → 7
✅ **로깅**: 실행 이력 자동 저장
✅ **에러 처리**: 문제 발생 시 로그 기록

### 사용 방법

```bash
# 실행
python project_grid_executor.py

# 결과
Phase 1: 20개 작업 실행
Phase 2: 24개 작업 실행
...
Phase 7: 18개 작업 실행

완료: 144/144개
```

### 실행 흐름

```
1. generated_grid_full_v4.json 로드
2. Phase별로 그룹화
3. Phase 1 시작:
   3.1. 의존성 없는 작업 찾기 (P1O1)
   3.2. Custom Agent 결정 (devops-troubleshooter)
   3.3. Agent .md 파일 읽기
   3.4. 작업 지시서 읽기
   3.5. Task tool로 간접 소환
   3.6. 완료 대기
   3.7. 다음 작업 (P1D1 - P1O1 의존)
   ...
4. Phase 2 시작
5. ...
7. Phase 7 완료
8. 실행 로그 저장
```

---

## FAQ

### Q1: 왜 직접 소환이 안 되나요?
A: 보안, 품질 관리, 기술 구조상 제약 때문입니다. Anthropic이 검증한 Built-in Agent만 직접 실행 가능합니다.

### Q2: 간접 소환으로 성능 저하는?
A: 거의 없습니다. .md 파일 읽기는 매우 빠르며, 프롬프트 길이만 약간 증가합니다.

### Q3: Custom Agent를 여러 개 조합할 수 있나요?
A: 가능합니다. 여러 .md 파일을 읽어서 하나의 프롬프트로 결합하면 됩니다.

```python
api_designer = Read("api-designer.md")
security_specialist = Read("security-specialist.md")

combined_prompt = f"""
{api_designer}

{security_specialist}

두 역할을 모두 고려해서 보안이 강화된 API를 설계하세요.
"""
```

### Q4: 144개를 일일이 실행해야 하나요?
A: 아니요. 통합 실행기가 자동으로 순차 실행합니다.

### Q5: 중간에 실패하면?
A: execution_log.json에 기록되며, 실패한 작업부터 재개할 수 있습니다.

---

## 핵심 정리

### ✅ DO
- 간접 소환 방식 사용
- .md 파일로 Agent 역할 정의
- 통합 실행기로 자동화
- 의존성 순서 준수

### ❌ DON'T
- 직접 소환 시도 (작동 안 함)
- Custom Agent를 subagent_type에 직접 입력
- 수동으로 144개 실행
- 의존성 무시

---

**문서 작성일**: 2025-10-31
**버전**: 1.0
**다음 업데이트**: 실제 실행 결과 반영 후
