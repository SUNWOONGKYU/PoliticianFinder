# P2S2 - SQL Injection 방어

**Phase**: Phase 2 - 정치인 목록/상세
**영역**: Security
**담당 AI**: security-auditor
**상태**: 대기
**진도**: 0%

---

## 📋 작업 개요

SQL Injection 공격을 방어하기 위한 보안 조치를 구현합니다. Supabase 클라이언트의 파라미터화된 쿼리를 활용하고, 입력값 검증을 강화합니다.

---

## 🎯 작업 목표

- [ ] 파라미터화된 쿼리 사용
- [ ] 입력값 검증 및 새니타이제이션
- [ ] SQL Injection 패턴 탐지
- [ ] 에러 메시지 정보 노출 방지
- [ ] ORM 안전 사용법 적용
- [ ] 보안 테스트 작성

---

## 📐 기술 사양

### Security
- ORM: Supabase Client (자동 파라미터화)
- Validation: Zod
- Testing: Jest

---

## 🔗 의존 작업

**선행 작업**: P2B1 (정치인 목록 API Route)
**후속 작업**: P3S2 (Rate Limiting - Phase 3)

---

## ✅ 완료 기준

1. 모든 쿼리 파라미터화 완료
2. 입력값 검증 로직 구현
3. SQL Injection 테스트 통과
4. 에러 메시지 새니타이제이션 완료
5. 보안 가이드라인 문서화

---

## 💻 구현 상세

### 1. Supabase 안전한 쿼리 패턴

```typescript
// lib/safe-query.ts
import { SupabaseClient } from '@supabase/supabase-js'

/**
 * SQL Injection으로부터 안전한 쿼리 헬퍼
 * Supabase 클라이언트는 자동으로 파라미터화를 제공하지만,
 * 추가 검증 레이어를 제공합니다.
 */

// ❌ 위험한 패턴 (절대 사용 금지)
// const query = `SELECT * FROM politicians WHERE name = '${userInput}'`

// ✅ 안전한 패턴
export async function safeFindPolitician(
  supabase: SupabaseClient,
  name: string
) {
  // Supabase는 자동으로 파라미터화
  const { data, error } = await supabase
    .from('politicians')
    .select('*')
    .eq('name', name)  // 파라미터화된 쿼리
    .single()

  return { data, error }
}

// ✅ LIKE 검색도 안전
export async function searchPoliticians(
  supabase: SupabaseClient,
  searchTerm: string
) {
  // 입력값 검증
  const sanitized = sanitizeSearchTerm(searchTerm)

  const { data, error } = await supabase
    .from('politicians')
    .select('*')
    .ilike('name', `%${sanitized}%`)  // 자동 이스케이프

  return { data, error }
}
```

### 2. 입력값 검증 (Zod)

```typescript
// lib/validation.ts
import { z } from 'zod'

// 정치인 검색 스키마
export const PoliticianSearchSchema = z.object({
  q: z.string()
    .max(100, '검색어는 100자를 초과할 수 없습니다')
    .regex(/^[a-zA-Z가-힣0-9\s]*$/, '허용되지 않은 문자가 포함되어 있습니다')
    .optional(),
  party: z.array(z.string()).max(10).optional(),
  region: z.array(z.string()).max(20).optional(),
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(10)
})

// 평가 생성 스키마
export const CreateRatingSchema = z.object({
  politician_id: z.number().int().positive(),
  score: z.number().int().min(1).max(5),
  comment: z.string()
    .max(1000, '코멘트는 1000자를 초과할 수 없습니다')
    .optional(),
  category: z.enum(['overall', 'policy', 'integrity', 'communication']).default('overall')
})

// 입력값 검증 헬퍼
export function validateInput<T>(schema: z.ZodSchema<T>, data: unknown): T {
  try {
    return schema.parse(data)
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`입력값 검증 실패: ${error.errors[0].message}`)
    }
    throw error
  }
}
```

### 3. 입력값 새니타이제이션

```typescript
// lib/sanitize.ts

/**
 * SQL Injection 위험 문자 제거
 */
export function sanitizeSearchTerm(input: string): string {
  if (typeof input !== 'string') {
    throw new Error('Invalid input type')
  }

  // 길이 제한
  if (input.length > 100) {
    throw new Error('Input too long')
  }

  // 위험한 SQL 키워드 패턴 탐지
  const dangerousPatterns = [
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE)\b)/gi,
    /(--|\|\||;|\/\*|\*\/)/g,  // SQL 코멘트 및 구분자
    /('|(\\')|(\\")|("))/g,      // 따옴표
    /(<|>|&lt;|&gt;)/g           // XSS 방어도 겸함
  ]

  for (const pattern of dangerousPatterns) {
    if (pattern.test(input)) {
      throw new Error('Invalid characters detected')
    }
  }

  // 안전한 문자만 허용 (화이트리스트)
  const sanitized = input.replace(/[^a-zA-Z가-힣0-9\s]/g, '')

  return sanitized.trim()
}

/**
 * 숫자 입력값 검증
 */
export function validateNumericInput(input: unknown): number {
  const num = Number(input)

  if (isNaN(num) || !isFinite(num)) {
    throw new Error('Invalid numeric input')
  }

  if (num < 0 || num > Number.MAX_SAFE_INTEGER) {
    throw new Error('Numeric input out of range')
  }

  return Math.floor(num)
}
```

### 4. API Route 보안 적용

```typescript
// app/api/politicians/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { PoliticianSearchSchema, validateInput } from '@/lib/validation'
import { sanitizeSearchTerm } from '@/lib/sanitize'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)

    // 입력값 검증
    const validatedParams = validateInput(PoliticianSearchSchema, {
      q: searchParams.get('q'),
      party: searchParams.get('party')?.split(','),
      region: searchParams.get('region')?.split(','),
      page: searchParams.get('page'),
      limit: searchParams.get('limit')
    })

    const supabase = createRouteHandlerClient({ cookies })

    // 안전한 쿼리 실행
    let query = supabase
      .from('politicians')
      .select('*', { count: 'exact' })

    // 검색어가 있는 경우
    if (validatedParams.q) {
      const sanitized = sanitizeSearchTerm(validatedParams.q)
      query = query.ilike('name', `%${sanitized}%`)  // 자동 이스케이프
    }

    // 필터 적용
    if (validatedParams.party && validatedParams.party.length > 0) {
      query = query.in('party', validatedParams.party)  // 파라미터화
    }

    if (validatedParams.region && validatedParams.region.length > 0) {
      query = query.in('region', validatedParams.region)
    }

    // 페이지네이션
    const start = (validatedParams.page - 1) * validatedParams.limit
    const end = start + validatedParams.limit - 1
    query = query.range(start, end)

    const { data, error, count } = await query

    if (error) {
      // 에러 메시지 새니타이제이션 (DB 정보 노출 방지)
      console.error('Database error:', error)
      return NextResponse.json(
        { error: 'Failed to fetch politicians' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      data,
      pagination: {
        page: validatedParams.page,
        limit: validatedParams.limit,
        total: count || 0
      }
    })
  } catch (error: any) {
    // 사용자에게는 일반적인 에러 메시지만 반환
    console.error('API error:', error)
    return NextResponse.json(
      { error: error.message || 'Internal server error' },
      { status: 400 }
    )
  }
}
```

### 5. SQL Injection 테스트

```typescript
// tests/security/sql-injection.test.ts
import { describe, test, expect } from '@jest/globals'
import { sanitizeSearchTerm, validateNumericInput } from '@/lib/sanitize'

describe('SQL Injection 방어', () => {
  test('SQL 키워드 차단', () => {
    expect(() => sanitizeSearchTerm("'; DROP TABLE politicians; --")).toThrow()
    expect(() => sanitizeSearchTerm("1' OR '1'='1")).toThrow()
    expect(() => sanitizeSearchTerm("admin'--")).toThrow()
  })

  test('SQL 코멘트 차단', () => {
    expect(() => sanitizeSearchTerm("test--comment")).toThrow()
    expect(() => sanitizeSearchTerm("test/*comment*/")).toThrow()
    expect(() => sanitizeSearchTerm("test||'test'")).toThrow()
  })

  test('따옴표 차단', () => {
    expect(() => sanitizeSearchTerm("test'test")).toThrow()
    expect(() => sanitizeSearchTerm('test"test')).toThrow()
  })

  test('Union 공격 차단', () => {
    expect(() => sanitizeSearchTerm("1' UNION SELECT * FROM users--")).toThrow()
  })

  test('안전한 입력은 통과', () => {
    expect(sanitizeSearchTerm('홍길동')).toBe('홍길동')
    expect(sanitizeSearchTerm('John Doe')).toBe('John Doe')
    expect(sanitizeSearchTerm('정치인 123')).toBe('정치인 123')
  })

  test('숫자 입력 검증', () => {
    expect(validateNumericInput('123')).toBe(123)
    expect(validateNumericInput(456)).toBe(456)
    expect(() => validateNumericInput('abc')).toThrow()
    expect(() => validateNumericInput(Infinity)).toThrow()
    expect(() => validateNumericInput(-1)).toThrow()
  })
})
```

### 6. E2E SQL Injection 테스트

```typescript
// tests/e2e/sql-injection.spec.ts
import { test, expect } from '@playwright/test'

test.describe('SQL Injection 방어 E2E', () => {
  test('검색창 SQL Injection 차단', async ({ page }) => {
    await page.goto('/politicians')

    // SQL Injection 시도
    const searchInput = page.locator('[data-testid="search-input"]')
    await searchInput.fill("'; DROP TABLE politicians; --")
    await searchInput.press('Enter')

    // 에러 메시지 표시 (DB 정보 노출 없이)
    await expect(page.locator('[data-testid="error-message"]')).toContainText(
      '입력값 검증 실패'
    )

    // 테이블은 여전히 존재 (공격 실패)
    await page.goto('/politicians')
    await expect(page.locator('[data-testid="politician-card"]')).toBeVisible()
  })

  test('URL 파라미터 SQL Injection 차단', async ({ page }) => {
    // 직접 URL 조작 시도
    const response = await page.goto(
      "/politicians?party='; DROP TABLE politicians; --"
    )

    expect(response?.status()).toBe(400)
  })
})
```

---

## 📝 보안 체크리스트

- [ ] 모든 사용자 입력 검증
- [ ] 파라미터화된 쿼리 사용
- [ ] SQL 키워드 패턴 탐지
- [ ] 에러 메시지 새니타이제이션
- [ ] 입력 길이 제한
- [ ] 숫자 입력 타입 검증
- [ ] 화이트리스트 방식 필터링

---

## 🔒 보안 가이드라인

### DO (권장)
- ✅ Supabase 클라이언트 메서드 사용 (자동 파라미터화)
- ✅ Zod로 입력값 스키마 검증
- ✅ 화이트리스트 방식 필터링
- ✅ 에러 메시지 일반화

### DON'T (금지)
- ❌ 문자열 템플릿으로 SQL 쿼리 작성
- ❌ 사용자 입력을 직접 쿼리에 삽입
- ❌ 상세한 DB 에러 노출
- ❌ 블랙리스트 방식 필터링 (우회 가능)

---

## 📌 참고사항

**작업 완료 일시**: 대기중
**테스트/검토 결과**: 대기
**자동화 방식**: AI-only
**블로커**: 없음
**비고**:
- Supabase는 기본적으로 SQL Injection 방어 제공
- 추가 검증 레이어로 방어 강화
- OWASP Top 10 취약점 중 1위

---

**작성 방법론**: 13DGC-AODM v1.1
**AI-Only 원칙 준수**: ✅
