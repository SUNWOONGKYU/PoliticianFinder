# P2B3 - í‰ê°€ ì§‘ê³„ ë¡œì§

**Phase**: Phase 2 - ì •ì¹˜ì¸ ëª©ë¡/ìƒì„¸
**ì˜ì—­**: Backend (Supabase)
**ë‹´ë‹¹ AI**: fullstack-developer
**ìƒíƒœ**: ëŒ€ê¸°
**ì§„ë„**: 0%

---

## ğŸ“‹ ì‘ì—… ê°œìš”

ì •ì¹˜ì¸ì˜ í‰ê·  í‰ì ì„ ìë™ìœ¼ë¡œ ê³„ì‚°í•˜ê³  ì—…ë°ì´íŠ¸í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•©ë‹ˆë‹¤. í‰ê°€ ìƒì„±/ìˆ˜ì •/ì‚­ì œ ì‹œ ìë™ìœ¼ë¡œ ì§‘ê³„ê°€ ì´ë£¨ì–´ì§€ë„ë¡ í•©ë‹ˆë‹¤.

---

## ğŸ¯ ì‘ì—… ëª©í‘œ

- [ ] í‰ê·  í‰ì  ê³„ì‚° í•¨ìˆ˜
- [ ] í‰ê°€ ê°œìˆ˜ ê³„ì‚° í•¨ìˆ˜
- [ ] ì¹´í…Œê³ ë¦¬ë³„ í‰ê·  ê³„ì‚°
- [ ] íŠ¸ë¦¬ê±° ë˜ëŠ” API í˜¸ì¶œ ë°©ì‹ êµ¬í˜„
- [ ] ì—ëŸ¬ í•¸ë“¤ë§
- [ ] ì„±ëŠ¥ ìµœì í™”

---

## ğŸ“ ê¸°ìˆ  ì‚¬ì–‘

### Backend
- Framework: Next.js 14 API Routes
- Database: Supabase (PostgreSQL)
- Language: TypeScript

### íŒŒì¼ êµ¬ì¡°
```
frontend/
  src/
    lib/
      rating-aggregator.ts
```

---

## ğŸ”— ì˜ì¡´ ì‘ì—…

**ì„ í–‰ ì‘ì—…**: P2B2 (ì‹œë¯¼ í‰ê°€ API)
**í›„ì† ì‘ì—…**: P2F6 (ì •ì¹˜ì¸ ìƒì„¸ í˜ì´ì§€)

---

## âœ… ì™„ë£Œ ê¸°ì¤€

1. í‰ê·  í‰ì  ê³„ì‚° ë¡œì§ êµ¬í˜„
2. í‰ê°€ ê°œìˆ˜ ì—…ë°ì´íŠ¸
3. ì¹´í…Œê³ ë¦¬ë³„ ì§‘ê³„
4. ì—ëŸ¬ í•¸ë“¤ë§
5. ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ í†µê³¼
6. TypeScript íƒ€ì… ì•ˆì •ì„±

---

## ğŸ’» êµ¬í˜„ ìƒì„¸

```typescript
// lib/rating-aggregator.ts
import { createClient } from '@supabase/supabase-js'

interface AggregationResult {
  avg_rating: number
  total_ratings: number
  category_scores?: Record<string, number>
}

export async function aggregateRatings(
  supabase: any,
  politician_id: number
): Promise<AggregationResult> {
  try {
    // ëª¨ë“  í‰ê°€ ì¡°íšŒ
    const { data: ratings, error } = await supabase
      .from('ratings')
      .select('score, category')
      .eq('politician_id', politician_id)

    if (error) throw error

    if (!ratings || ratings.length === 0) {
      return {
        avg_rating: 0,
        total_ratings: 0
      }
    }

    // ì „ì²´ í‰ê·  ê³„ì‚°
    const totalScore = ratings.reduce((sum, r) => sum + r.score, 0)
    const avg_rating = Math.round((totalScore / ratings.length) * 10) / 10

    // ì¹´í…Œê³ ë¦¬ë³„ í‰ê·  ê³„ì‚°
    const categoryScores: Record<string, number[]> = {}

    ratings.forEach(r => {
      if (r.category) {
        if (!categoryScores[r.category]) {
          categoryScores[r.category] = []
        }
        categoryScores[r.category].push(r.score)
      }
    })

    const category_scores: Record<string, number> = {}
    Object.keys(categoryScores).forEach(category => {
      const scores = categoryScores[category]
      category_scores[category] = Math.round(
        (scores.reduce((sum, s) => sum + s, 0) / scores.length) * 10
      ) / 10
    })

    // politicians í…Œì´ë¸” ì—…ë°ì´íŠ¸
    await supabase
      .from('politicians')
      .update({
        avg_rating,
        total_ratings: ratings.length,
        updated_at: new Date().toISOString()
      })
      .eq('id', politician_id)

    return {
      avg_rating,
      total_ratings: ratings.length,
      category_scores
    }
  } catch (error) {
    console.error('Aggregation error:', error)
    throw error
  }
}

export async function aggregateAllPoliticians(supabase: any) {
  const { data: politicians } = await supabase
    .from('politicians')
    .select('id')

  if (!politicians) return

  for (const politician of politicians) {
    await aggregateRatings(supabase, politician.id)
  }
}
```

---

## ğŸ“ í…ŒìŠ¤íŠ¸ ê³„íš

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- [ ] í‰ê·  ê³„ì‚° ë¡œì§ í…ŒìŠ¤íŠ¸
- [ ] ì¹´í…Œê³ ë¦¬ë³„ ì§‘ê³„ í…ŒìŠ¤íŠ¸
- [ ] ë¹ˆ ë°ì´í„° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸

### í†µí•© í…ŒìŠ¤íŠ¸
- [ ] í‰ê°€ ìƒì„± í›„ ì§‘ê³„ í…ŒìŠ¤íŠ¸
- [ ] í‰ê°€ ì‚­ì œ í›„ ì¬ì§‘ê³„ í…ŒìŠ¤íŠ¸
- [ ] ëŒ€ëŸ‰ ë°ì´í„° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸

---

## ğŸ”’ ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

- SQL Injection ë°©ì§€
- ë°ì´í„° ì •í•©ì„± ë³´ì¥

---

## ğŸ“Œ ì°¸ê³ ì‚¬í•­

**ì‘ì—… ì™„ë£Œ ì¼ì‹œ**: ëŒ€ê¸°ì¤‘
**í…ŒìŠ¤íŠ¸/ê²€í†  ê²°ê³¼**: ëŒ€ê¸°
**ìë™í™” ë°©ì‹**: AI-only
**ë¸”ë¡œì»¤**: ì—†ìŒ
**ë¹„ê³ **: -

---

**ì‘ì„± ë°©ë²•ë¡ **: 15DGC-AODM v3.0
**AI-Only ì›ì¹™ ì¤€ìˆ˜**: âœ…
