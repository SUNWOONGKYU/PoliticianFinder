import { test, expect } from '@playwright/test';

test.describe('Penetration Testing - Security Validation', () => {
  test.describe('Authentication Security', () => {
    test('should prevent SQL injection in login', async ({ page }) => {
      await page.goto('/login');

      // Try SQL injection
      await page.fill('input[name="email"]', "admin' OR '1'='1");
      await page.fill('input[name="password"]', "admin' OR '1'='1");
      await page.click('button[type="submit"]');

      // Should not login
      await expect(page).not.toHaveURL(/.*profile/);
      await expect(page.locator('text=/invalid|error/i')).toBeVisible();
    });

    test('should enforce rate limiting on login', async ({ page }) => {
      await page.goto('/login');

      // Attempt multiple failed logins
      for (let i = 0; i < 6; i++) {
        await page.fill('input[name="email"]', 'test@example.com');
        await page.fill('input[name="password"]', 'wrongpassword' + i);
        await page.click('button[type="submit"]');
        await page.waitForTimeout(500);
      }

      // Should show rate limit message
      await expect(page.locator('text=/too many|rate limit/i')).toBeVisible();
    });

    test('should enforce password complexity', async ({ page }) => {
      await page.goto('/signup');

      // Try weak password
      await page.fill('input[name="email"]', 'test@example.com');
      await page.fill('input[name="password"]', '123');
      await page.click('button[type="submit"]');

      // Should show error
      await expect(page.locator('text=/password.*8.*characters/i')).toBeVisible();
    });
  });

  test.describe('XSS Protection', () => {
    test('should sanitize comment input', async ({ page, context }) => {
      // Mock authentication
      await context.addCookies([{
        name: 'auth-token',
        value: 'mock-token',
        domain: 'localhost',
        path: '/',
      }]);

      await page.goto('/politicians/1');

      // Try XSS in comment
      const xssPayload = '<script>alert("XSS")</script>';
      await page.fill('textarea[name="comment"]', xssPayload);
      await page.click('button:has-text("Post Comment")');

      await page.waitForTimeout(1000);

      // Check that script tag was sanitized
      const comments = page.locator('[data-testid="comment"]');
      const commentText = await comments.first().textContent();
      expect(commentText).not.toContain('<script>');
    });

    test('should sanitize image XSS in profile', async ({ page, context }) => {
      await context.addCookies([{
        name: 'auth-token',
        value: 'mock-token',
        domain: 'localhost',
        path: '/',
      }]);

      await page.goto('/profile');

      // Try XSS via image onerror
      await page.fill('input[name="bio"]', '<img src=x onerror=alert("XSS")>');
      await page.click('button:has-text("Save")');

      await page.waitForTimeout(1000);

      // Should not execute script
      const bio = page.locator('[data-testid="user-bio"]');
      const bioHTML = await bio.innerHTML();
      expect(bioHTML).not.toContain('onerror');
    });
  });

  test.describe('Authorization Testing', () => {
    test('should prevent unauthorized access to admin routes', async ({ page }) => {
      await page.goto('/admin/beta-testers');

      // Should redirect to login or show error
      await expect(page).toHaveURL(/.*login|.*unauthorized/);
    });

    test('should prevent accessing other users data', async ({ page, request }) => {
      // Try to access another user's bookmarks via API
      const response = await request.get('/api/users/999/bookmarks', {
        headers: {
          'Authorization': 'Bearer fake-token',
        },
      });

      expect(response.status()).toBe(401);
    });

    test('should prevent modifying other users ratings', async ({ request }) => {
      const response = await request.put('/api/ratings/123', {
        headers: {
          'Authorization': 'Bearer fake-token',
        },
        data: {
          rating: 1,
        },
      });

      expect(response.status()).toBe(401);
    });
  });

  test.describe('CSRF Protection', () => {
    test('should reject requests without proper origin', async ({ request }) => {
      const response = await request.post('/api/ratings', {
        headers: {
          'Origin': 'https://evil.com',
          'Authorization': 'Bearer valid-token',
        },
        data: {
          politician_id: 1,
          rating: 5,
        },
      });

      // Should be rejected due to CORS
      expect(response.status()).not.toBe(200);
    });
  });

  test.describe('Input Validation', () => {
    test('should reject oversized payloads', async ({ request }) => {
      const largeComment = 'A'.repeat(100000);
      const response = await request.post('/api/comments', {
        data: {
          content: largeComment,
        },
      });

      expect(response.status()).toBe(400);
    });

    test('should validate rating range', async ({ request }) => {
      // Negative rating
      let response = await request.post('/api/ratings', {
        data: {
          politician_id: 1,
          rating: -5,
        },
      });
      expect(response.status()).toBe(400);

      // Excessive rating
      response = await request.post('/api/ratings', {
        data: {
          politician_id: 1,
          rating: 999,
        },
      });
      expect(response.status()).toBe(400);
    });

    test('should validate email format', async ({ page }) => {
      await page.goto('/signup');

      await page.fill('input[name="email"]', 'invalid-email');
      await page.click('button[type="submit"]');

      await expect(page.locator('text=/invalid.*email/i')).toBeVisible();
    });
  });

  test.describe('API Security', () => {
    test('should enforce rate limiting on API endpoints', async ({ request }) => {
      // Rapid requests
      const requests = [];
      for (let i = 0; i < 100; i++) {
        requests.push(request.get('/api/politicians'));
      }

      const responses = await Promise.all(requests);
      const rateLimited = responses.some(r => r.status() === 429);

      expect(rateLimited).toBeTruthy();
    });

    test('should require authentication for protected endpoints', async ({ request }) => {
      const endpoints = [
        '/api/bookmarks',
        '/api/ratings',
        '/api/comments',
        '/api/users/me',
      ];

      for (const endpoint of endpoints) {
        const response = await request.get(endpoint);
        expect(response.status()).toBe(401);
      }
    });
  });

  test.describe('File Upload Security', () => {
    test('should reject executable files', async ({ page, context }) => {
      await context.addCookies([{
        name: 'auth-token',
        value: 'mock-token',
        domain: 'localhost',
        path: '/',
      }]);

      await page.goto('/profile');

      // Try to upload .exe file
      const fileInput = page.locator('input[type="file"]');
      await fileInput.setInputFiles({
        name: 'malicious.exe',
        mimeType: 'application/x-msdownload',
        buffer: Buffer.from('fake executable'),
      });

      await expect(page.locator('text=/invalid file type/i')).toBeVisible();
    });

    test('should enforce file size limits', async ({ page, context }) => {
      await context.addCookies([{
        name: 'auth-token',
        value: 'mock-token',
        domain: 'localhost',
        path: '/',
      }]);

      await page.goto('/profile');

      // Try to upload large file
      const largeBuffer = Buffer.alloc(11 * 1024 * 1024); // 11MB
      const fileInput = page.locator('input[type="file"]');
      await fileInput.setInputFiles({
        name: 'large.jpg',
        mimeType: 'image/jpeg',
        buffer: largeBuffer,
      });

      await expect(page.locator('text=/file too large|size limit/i')).toBeVisible();
    });
  });

  test.describe('Security Headers', () => {
    test('should set proper security headers', async ({ page }) => {
      const response = await page.goto('/');

      const headers = response?.headers() || {};

      // Check security headers
      expect(headers['strict-transport-security']).toBeTruthy();
      expect(headers['x-content-type-options']).toBe('nosniff');
      expect(headers['x-frame-options']).toBe('DENY');
      expect(headers['x-xss-protection']).toBeTruthy();
      expect(headers['referrer-policy']).toBeTruthy();
    });

    test('should enforce HTTPS', async ({ page }) => {
      const response = await page.goto('/');
      const protocol = new URL(response?.url() || '').protocol;
      expect(protocol).toBe('https:');
    });
  });

  test.describe('Session Security', () => {
    test('should invalidate session on logout', async ({ page, context }) => {
      await context.addCookies([{
        name: 'auth-token',
        value: 'valid-token',
        domain: 'localhost',
        path: '/',
      }]);

      await page.goto('/profile');
      await expect(page.locator('[data-testid="user-profile"]')).toBeVisible();

      // Logout
      await page.click('[data-testid="logout-button"]');

      // Try to access protected route
      await page.goto('/profile');
      await expect(page).toHaveURL(/.*login/);
    });

    test('should enforce session timeout', async ({ page, context }) => {
      // Set expired cookie
      await context.addCookies([{
        name: 'auth-token',
        value: 'expired-token',
        domain: 'localhost',
        path: '/',
        expires: Math.floor(Date.now() / 1000) - 3600, // 1 hour ago
      }]);

      await page.goto('/profile');
      await expect(page).toHaveURL(/.*login/);
    });
  });

  test.describe('Error Handling', () => {
    test('should not expose stack traces', async ({ request }) => {
      const response = await request.post('/api/invalid-endpoint', {
        data: { malformed: 'data' },
      });

      const body = await response.text();
      expect(body).not.toContain('Error:');
      expect(body).not.toContain('at ');
      expect(body).not.toContain('.js:');
    });

    test('should use generic error messages', async ({ page }) => {
      await page.goto('/login');

      await page.fill('input[name="email"]', 'test@example.com');
      await page.fill('input[name="password"]', 'wrongpassword');
      await page.click('button[type="submit"]');

      const error = page.locator('[role="alert"]');
      const errorText = await error.textContent();

      // Should not reveal whether email exists
      expect(errorText?.toLowerCase()).not.toContain('email not found');
      expect(errorText?.toLowerCase()).toContain('invalid');
    });
  });

  test.describe('Business Logic Security', () => {
    test('should prevent duplicate voting', async ({ page, context }) => {
      await context.addCookies([{
        name: 'auth-token',
        value: 'valid-token',
        domain: 'localhost',
        path: '/',
      }]);

      await page.goto('/politicians/1');

      // Vote once
      await page.click('[data-testid="star-5"]');
      await page.click('button:has-text("Submit Rating")');
      await expect(page.locator('text=/success/i')).toBeVisible();

      // Try to vote again
      await page.reload();
      await page.click('[data-testid="star-1"]');
      await page.click('button:has-text("Submit Rating")');

      // Should prevent or update existing rating
      await expect(page.locator('text=/already rated|update/i')).toBeVisible();
    });

    test('should prevent race conditions in bookmarking', async ({ request }) => {
      // Simultaneous bookmark requests
      const requests = [];
      for (let i = 0; i < 10; i++) {
        requests.push(
          request.post('/api/bookmarks', {
            headers: { 'Authorization': 'Bearer valid-token' },
            data: { politician_id: 1 },
          })
        );
      }

      await Promise.all(requests);

      // Verify only one bookmark created
      const response = await request.get('/api/bookmarks', {
        headers: { 'Authorization': 'Bearer valid-token' },
      });

      const data = await response.json();
      const bookmarksForPolitician = data.filter((b: any) => b.politician_id === 1);
      expect(bookmarksForPolitician.length).toBe(1);
    });
  });
});
