# P1S2 - 입력 검증 및 SQL 인젝션 방지

## 작업 ID
P1S2

## 담당 영역
Security

## 작업 개요
사용자 입력에 대한 검증과 sanitization을 구현하여 SQL 인젝션, XSS 등의 공격을 방지합니다.

## 상세 설명
클라이언트와 서버 양쪽에서 입력 검증을 수행하고, Supabase의 파라미터화된 쿼리를 사용하여 SQL 인젝션을 방지합니다.

## 기술 스택
- Zod (스키마 검증)
- DOMPurify (XSS 방지)
- Supabase (파라미터화된 쿼리)
- React Hook Form

## 구현 사항
1. Zod 스키마 정의
2. 입력 검증 미들웨어
3. XSS 방지 (DOMPurify)
4. SQL 인젝션 방지 (Supabase 사용)
5. Rate Limiting

## 1. Zod 스키마 정의

### 설치
```bash
npm install zod
```

### schemas/auth.js
```javascript
import { z } from 'zod'

export const signupSchema = z.object({
  email: z
    .string()
    .email('유효한 이메일을 입력하세요')
    .min(5, '이메일은 최소 5자 이상이어야 합니다')
    .max(100, '이메일은 최대 100자까지 입력 가능합니다'),
  password: z
    .string()
    .min(8, '비밀번호는 최소 8자 이상이어야 합니다')
    .max(100, '비밀번호는 최대 100자까지 입력 가능합니다')
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      '비밀번호는 대소문자와 숫자를 포함해야 합니다'
    ),
  name: z
    .string()
    .min(2, '이름은 최소 2자 이상이어야 합니다')
    .max(50, '이름은 최대 50자까지 입력 가능합니다')
    .regex(/^[가-힣a-zA-Z\s]+$/, '이름은 한글, 영문, 공백만 입력 가능합니다'),
})

export const loginSchema = z.object({
  email: z.string().email('유효한 이메일을 입력하세요'),
  password: z.string().min(1, '비밀번호를 입력하세요'),
})

export const profileUpdateSchema = z.object({
  name: z.string().min(2).max(50).optional(),
  bio: z.string().max(500).optional(),
  avatar_url: z.string().url().optional(),
})
```

## 2. API Route 입력 검증 미들웨어

### middleware/validateRequest.js
```javascript
export function validateRequest(schema) {
  return async (req, res, next) => {
    try {
      const validated = await schema.parseAsync(req.body)
      req.validatedBody = validated
      next()
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          error: 'Validation failed',
          details: error.errors.map((err) => ({
            field: err.path.join('.'),
            message: err.message,
          })),
        })
      }
      return res.status(500).json({ error: 'Internal server error' })
    }
  }
}
```

### API Route 사용 예시
```javascript
// pages/api/auth/signup.js
import { validateRequest } from '@/middleware/validateRequest'
import { signupSchema } from '@/schemas/auth'

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  // 입력 검증
  try {
    const data = signupSchema.parse(req.body)
    
    // 검증된 데이터로 회원가입 처리
    const { email, password, name } = data
    // ...
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.errors,
      })
    }
    return res.status(500).json({ error: 'Internal server error' })
  }
}
```

## 3. XSS 방지 (DOMPurify)

### 설치
```bash
npm install dompurify
npm install --save-dev @types/dompurify
```

### utils/sanitize.js
```javascript
import DOMPurify from 'dompurify'

export function sanitizeHtml(dirty) {
  if (typeof window === 'undefined') {
    // 서버 사이드에서는 간단한 처리
    return dirty.replace(/</g, '&lt;').replace(/>/g, '&gt;')
  }
  
  // 클라이언트 사이드에서는 DOMPurify 사용
  return DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
    ALLOWED_ATTR: ['href'],
  })
}

export function escapeHtml(text) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  }
  return text.replace(/[&<>"']/g, (m) => map[m])
}
```

### 사용 예시
```javascript
import { sanitizeHtml, escapeHtml } from '@/utils/sanitize'

// 댓글 표시 시
<div dangerouslySetInnerHTML={{ __html: sanitizeHtml(comment.content) }} />

// 일반 텍스트
<p>{escapeHtml(user.name)}</p>
```

## 4. SQL 인젝션 방지

### Supabase는 자동으로 파라미터화된 쿼리 사용
```javascript
// ✅ 안전 (Supabase가 자동 이스케이프)
const { data, error } = await supabase
  .from('politicians')
  .select('*')
  .eq('name', userInput)

// ❌ 위험 (Raw SQL은 사용하지 않음)
// const { data } = await supabase.rpc('raw_sql', { 
//   query: `SELECT * FROM politicians WHERE name = '${userInput}'` 
// })
```

### RPC 함수 사용 시 주의
```sql
-- Supabase에서 RPC 함수 생성 시 파라미터 사용
CREATE OR REPLACE FUNCTION search_politicians(search_term TEXT)
RETURNS TABLE (id UUID, name TEXT, party TEXT)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT p.id, p.name, p.party
  FROM politicians p
  WHERE p.name ILIKE '%' || search_term || '%';
END;
$$;
```

## 5. Rate Limiting

### utils/rateLimiter.js
```javascript
const rateLimit = new Map()

export function checkRateLimit(identifier, maxRequests = 10, windowMs = 60000) {
  const now = Date.now()
  const userRequests = rateLimit.get(identifier) || []
  
  // 윈도우 밖의 요청 제거
  const recentRequests = userRequests.filter(
    (timestamp) => now - timestamp < windowMs
  )
  
  if (recentRequests.length >= maxRequests) {
    return false // Rate limit 초과
  }
  
  recentRequests.push(now)
  rateLimit.set(identifier, recentRequests)
  return true
}
```

### API Route에서 사용
```javascript
import { checkRateLimit } from '@/utils/rateLimiter'

export default async function handler(req, res) {
  const identifier = req.headers['x-forwarded-for'] || req.connection.remoteAddress
  
  if (!checkRateLimit(identifier, 10, 60000)) {
    return res.status(429).json({ 
      error: 'Too many requests. Please try again later.' 
    })
  }
  
  // 실제 로직
}
```

## 보안 체크리스트
- [ ] 모든 사용자 입력에 Zod 검증 적용
- [ ] XSS 방지를 위한 sanitization 구현
- [ ] Supabase 파라미터화된 쿼리 사용
- [ ] Rate Limiting 구현
- [ ] 에러 메시지에 민감한 정보 포함 안 함
- [ ] 파일 업로드 시 파일 타입 검증
- [ ] 파일 크기 제한

## 입력 검증 원칙
1. **클라이언트 검증**: UX 개선
2. **서버 검증**: 보안 (필수)
3. **데이터베이스 제약**: 최종 방어선

## 성공 기준
- [ ] Zod 스키마 모든 폼에 적용
- [ ] API Route 입력 검증 구현
- [ ] XSS 방지 sanitization 적용
- [ ] SQL 인젝션 테스트 통과
- [ ] Rate Limiting 작동 확인
- [ ] 악의적 입력 테스트 통과

## 의존 작업
- P1F2~P1F5 (폼 페이지들)
- P1B3~P1B6 (API Routes)

## 예상 소요 시간
3시간

## 참고 사항
- Supabase는 기본적으로 SQL 인젝션에 안전
- 사용자 입력을 HTML로 렌더링할 때 특히 주의
- 정규식 검증 시 ReDoS 공격 주의
- 파일 업로드는 별도 보안 정책 필요
