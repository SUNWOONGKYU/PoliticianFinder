# P2B3 - 평가 집계 로직

**Phase**: Phase 2 - 정치인 목록/상세
**영역**: Backend (Supabase)
**담당 AI**: fullstack-developer
**상태**: 대기
**진도**: 0%

---

## 📋 작업 개요

정치인의 평균 평점을 자동으로 계산하고 업데이트하는 로직을 구현합니다. 평가 생성/수정/삭제 시 자동으로 집계가 이루어지도록 합니다.

---

## 🎯 작업 목표

- [ ] 평균 평점 계산 함수
- [ ] 평가 개수 계산 함수
- [ ] 카테고리별 평균 계산
- [ ] 트리거 또는 API 호출 방식 구현
- [ ] 에러 핸들링
- [ ] 성능 최적화

---

## 📐 기술 사양

### Backend
- Framework: Next.js 14 API Routes
- Database: Supabase (PostgreSQL)
- Language: TypeScript

### 파일 구조
```
frontend/
  src/
    lib/
      rating-aggregator.ts
```

---

## 🔗 의존 작업

**선행 작업**: P2B2 (시민 평가 API)
**후속 작업**: P2F6 (정치인 상세 페이지)

---

## ✅ 완료 기준

1. 평균 평점 계산 로직 구현
2. 평가 개수 업데이트
3. 카테고리별 집계
4. 에러 핸들링
5. 성능 테스트 통과
6. TypeScript 타입 안정성

---

## 💻 구현 상세

```typescript
// lib/rating-aggregator.ts
import { createClient } from '@supabase/supabase-js'

interface AggregationResult {
  avg_rating: number
  total_ratings: number
  category_scores?: Record<string, number>
}

export async function aggregateRatings(
  supabase: any,
  politician_id: number
): Promise<AggregationResult> {
  try {
    // 모든 평가 조회
    const { data: ratings, error } = await supabase
      .from('ratings')
      .select('score, category')
      .eq('politician_id', politician_id)

    if (error) throw error

    if (!ratings || ratings.length === 0) {
      return {
        avg_rating: 0,
        total_ratings: 0
      }
    }

    // 전체 평균 계산
    const totalScore = ratings.reduce((sum, r) => sum + r.score, 0)
    const avg_rating = Math.round((totalScore / ratings.length) * 10) / 10

    // 카테고리별 평균 계산
    const categoryScores: Record<string, number[]> = {}

    ratings.forEach(r => {
      if (r.category) {
        if (!categoryScores[r.category]) {
          categoryScores[r.category] = []
        }
        categoryScores[r.category].push(r.score)
      }
    })

    const category_scores: Record<string, number> = {}
    Object.keys(categoryScores).forEach(category => {
      const scores = categoryScores[category]
      category_scores[category] = Math.round(
        (scores.reduce((sum, s) => sum + s, 0) / scores.length) * 10
      ) / 10
    })

    // politicians 테이블 업데이트
    await supabase
      .from('politicians')
      .update({
        avg_rating,
        total_ratings: ratings.length,
        updated_at: new Date().toISOString()
      })
      .eq('id', politician_id)

    return {
      avg_rating,
      total_ratings: ratings.length,
      category_scores
    }
  } catch (error) {
    console.error('Aggregation error:', error)
    throw error
  }
}

export async function aggregateAllPoliticians(supabase: any) {
  const { data: politicians } = await supabase
    .from('politicians')
    .select('id')

  if (!politicians) return

  for (const politician of politicians) {
    await aggregateRatings(supabase, politician.id)
  }
}
```

---

## 📝 테스트 계획

### 단위 테스트
- [ ] 평균 계산 로직 테스트
- [ ] 카테고리별 집계 테스트
- [ ] 빈 데이터 처리 테스트

### 통합 테스트
- [ ] 평가 생성 후 집계 테스트
- [ ] 평가 삭제 후 재집계 테스트
- [ ] 대량 데이터 성능 테스트

---

## 🔒 보안 고려사항

- SQL Injection 방지
- 데이터 정합성 보장

---

## 📌 참고사항

**작업 완료 일시**: 대기중
**테스트/검토 결과**: 대기
**자동화 방식**: AI-only
**블로커**: 없음
**비고**: -

---

**작성 방법론**: 15DGC-AODM v3.0
**AI-Only 원칙 준수**: ✅
